# 数据结构和算法入门

解决问题方法的效率，跟数据的组织方式有关

解决问题方法的效率，跟空间的利用效率有关

解决问题方法的效率，跟算法的巧妙程度有关

### 什么是数据结构

- **数据对象**在计算机中的组织方式
	- 逻辑结构
	- 物理存储结构
- 数据对象必定与一系列加在其上的**操作**相关联
- 完成这些操作所用的方法就是**算法**



### 抽象数据类型

- 数据类型
  - 数据对象集
  - 数据集合相关联的操作集
- 抽象：描述数据类型的方法不依赖于具体实现
  - 与存放数据的机器无关
  - 与数据存储的物理结构无关
  - 与实现操作的算法和编程语言均无关

只描述数据对象集和相关操作集“ **是什么”**，并不涉及 “ **如何做到**”的问题 

#### 举例：“矩阵”的抽象数据类型定义

- 类型名称： 矩阵（Matrix ）

- 数据对象集：一个M×N的矩阵A[M×N]=(aij)

- 操作集

  - Matrix create(int M,int N);
  - int getMaxRow(Matrix A);
  - int getMaxCol(Matrix A);
  - ElementType getEntry(Matrix A,int i,int j);
  - Matrix Add(Matrix A,Matrix B);
  - ...

  

### 什么是算法

- 一个有限指令集
- 接受一些输入（有些情况下不需要输入）
- 产生输出
- 一定在有限步骤之后终止
- 每一条指令必须
  - 有充分明确的目标，不可以有歧义
  - 计算机能处理的范围之内
  - 描述应不依赖于任何一种计算机语言以及具体的实现手段

### 什么是好的算法

- 空间复杂度S(n)

  根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。

- 时间复杂度T(n)

  根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。

#### 空间复杂度举例

场景：打印1到N

代码如下：

```c
void PrintN ( int N )
{ 
    if ( N ){
        PrintN( N – 1 );
        printf(“%d\n”, N );
    }
	return;
}
```

上述代码通过递归思想来打印1到N，看似好像没有定义临时变量，但其实，每一次递归调用都需要耗费内存来维护当前函数的执行状态，一直到N为0时开始一层层往回执行。当N足够大时，内存显然是不够用的。

#### 时间复杂度举例

场景：多项式如下

![clip_image002.png](http://ww1.sinaimg.cn/large/008048Tsgy1g8h7x1q4f7j303q02m3yd.jpg)

给定任意的x，求结果

一般的思路

```c
//其中n表示多项式的项数，a表示每一项对应的系数
//这里假定每一项的系数就是i
double f1( int n, double a[], double x )
{ 
    int i;
    double p = a[0];
    for ( i=1; i<=n; i++ )
    	p += (a[i] * pow(x, i));
    return p;
}
```

这个算法是最直观的，直接表示出通项公式，然后利用公式求和，最终的时间复杂度为n的平方



好的算法

```c
double f( int n, double a[], double x )
{ 
    int i;
	double p = a[n];
	for ( i=n; i>0; i-- )
		p = a[i-1] + x*p;
	return p;
}
```

通过提取多项式，化简之后，时间复杂度减小为n

### 常见时间复杂度

![Snipaste_2019-10-31_11-40-40.png](http://ww1.sinaimg.cn/large/008048Tsgy1g8h8eslhyyj30il08c756.jpg)



